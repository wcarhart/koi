#!/bin/bash
set -e

# ============ STARTUP FUNCTIONALITY ============ #
koiname=koi
koidescription="Bashful argument parsing"
koicolors=1
shortoptions=( )
longoptions=( )
actions=( )
requireds=( )
defaults=( )
helptexts=( )

# ============ CLI FUNCTIONS ============ #
function list {
	__addarg "-h" "--help" "help" "optional" "" "List all available commands"
	__parseargs "$@"
	__listfunctions
}

function help {
	__addarg "-h" "--help" "help" "optional" "" "Show this menu and exit"
	__addarg "-v" "--verbose" "flag" "optional" "" "Print verbose command documentation"
	__parseargs "$@"

	# check for __addarg errors
	for cmd in `__listfunctions` ; do
		exec 3>&1
		local stderr="$(__cleararglists ; $cmd --help </dev/stdin 2>&1 1>&3 1> /dev/null)"
		if [[ "$stderr" != "" ]] ; then
			__errortext "$stderr"
			return 1
		fi
	done

	local colorteal=
	local coloryellow=
	local colorreset=
	if [[ "$koicolors" -eq 1 ]] ; then
		colorteal='\033[96m'
		coloryellow='\033[93m'
		colorreset='\033[0m'
	fi

	local helpoutput=$(cat <<- EndOfHelp
	${coloryellow}${koidescription}${colorreset}

	${colorteal}Usage:${colorreset}
	  $koiname COMMAND [args]

	${colorteal}Available commands:${colorreset}
	$( \
		for cmd in `__listfunctions` ; do \
			echo "  $cmd" ; \
		done \
	)
	EndOfHelp
	)
	echo -e "$helpoutput"
	echo

	if [[ "$verbose" -eq 1 ]] ; then
		helpoutput=$(cat <<- EndOfHelp
		${colorteal}Command documentation:${colorreset}
		$( \
			for cmd in `__listfunctions` ; do \
				echo "$(__cleararglists ; $cmd --help)" && \
				echo ; \
			done \
		)

		EndOfHelp
		)
	else
		helpoutput=$(cat <<- EndOfHelp
		${colorteal}Hints:${colorreset}
		  $koiname help --verbose    Show complete command documentation
		  $koiname COMMAND --help    Show individual command documentation

		EndOfHelp
		)
	fi
	echo -e "$helpoutput"
	echo
}

# ============ META FUNCTIONS ============ #
function __listfunctions {
	functionlist=( `declare -F | sed -e 's/declare -f //g' -e 's/[_-].*//g'` )
	for func in "${functionlist[@]}" ; do
		echo "$func"
	done
}

function __addarg {
	: <<- COMMENT
	Add an argument to parse for a function
		$1 - short option (optional)
		$2 - long option (required)
		$3 - action to take with argument (required)
		$4 - whether or not argument is required (required)
		$5 - the default value for the argument (optional)
		$6 - the help text to print when -h is specified (optional)
	COMMENT

	if [[ $# -ne 6 ]] ; then __errortext "$koiname: __addarg err: incorrect usage, 6 arguments are required" ; return 1 ; fi

	# short option
	if [[ "$1" != "" ]] ; then
		if [[ "$1" != -* || "$1" == --* ]] ; then __errortext "$koiname: __addarg err: short option must start with a single dash" ; return 1 ; fi
		if [[ "${#1}" -gt 2 ]] ; then __errortext "$koiname: __addarg err: short options must be a single dash followed by a single letter" ; return 1 ; fi
		if [[ "$1" == *" "* ]] ; then __errortext "$koiname: __addarg err: short option cannot contain a space" ; return 1 ; fi
		if [[ "$1" =~ [0-9] ]] ; then __errortext "$koiname: __addarg err: short option cannot contain a number" ; return 1 ; fi
	fi

	# long option
	if [[ "$2" == "" ]] ; then __errortext "$koiname: __addarg err: missing long option for argument" ; return 1 ; fi
	if [[ "$2" != --* ]] ; then
		if [[ "$3" != "positionalvalue" && "$3" != "positionalarray" ]] ; then
			__errortext "$koiname: __addarg err: long option must start with a double dash"
			return 1
		fi
	fi
	if [[ "$2" == *" "* ]] ; then __errortext "$koiname: __addarg err: long option cannot contain a space" ; return 1 ; fi
	if [[ "$2" =~ [0-9] ]] ; then __errortext "$koiname: __addarg err: long option cannot contain a number" ; return 1 ; fi

	# action
	availableactions="help storevalue storearray filepath directorypath positionalvalue positionalarray flag exit"
	if [[ "$3" == "" ]] ; then __errortext "$koiname: __addarg err: missing action for argument" ; return 1 ; fi
	found=0
	for action in $availableactions ; do if [[ "$action" == "$3" ]] ; then found=1 ; fi ; done
	if [[ $found -eq 0 ]] ; then __errortext "$koiname: __addarg err: action must be one of: $availableactions" ; return 1 ; fi
	if [[ "$3" == "positionalvalue" || "$3" == "positionalarray" ]] ; then
		if [[ "$1" != "" ]] ; then __errortext "$koiname: __addarg err: positional arguments cannot have a short name" ; return 1 ; fi
		if [[ "$2" == -* ]] ; then __errortext "$koiname: __addarg err: positional arguments long name cannot begin with a dash" ; return 1 ; fi
	fi

	# required
	if [[ "$4" == "" ]] ; then __errortext "$koiname: __addarg err: missing required for argument" ; return 1 ; fi
	if [[ "$4" != "required" && "$4" != "optional" ]] ; then __errortext "$koiname: __addarg err: required must be one of: required optional" ; return 1 ; fi
	if [[ "$3" == "help" && "$4" == "required" ]] ; then __errortext "$koiname: __addarg err: help option cannot be required" ; return 1 ; fi

	# default
	if [[ "$4" == "required" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: required arguments cannot have default values" ; return 1 ; fi
	if [[ "$3" == "help" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: help action cannot have a default value" ; return 1 ; fi
	if [[ "$3" == "flag" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: flags cannot have default values" ; return 1 ; fi
	if [[ "$3" == "storearray" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: arrays cannot have default values" ; return 1 ; fi
	if [[ "$3" == "positionalvalue" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: positional values cannot have default values" ; return 1 ; fi
	if [[ "$3" == "positionalarray" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: positional arrays cannot have default values" ; return 1 ; fi

	# help
	if [[ "$6" == "" ]] ; then __errortext "$koiname: __addarg err: missing help text for argument" ; return 1 ; fi

	shortoptions=( "${shortoptions[@]}" "$1" )
	longoptions=( "${longoptions[@]}" "$2" )
	actions=( "${actions[@]}" "$3" )
	requireds=( "${requireds[@]}" "$4" )
	defaults=( "${defaults[@]}" "$5" )
	helptexts=( "${helptexts[@]}" "$6" )

	# verify nonambiguity
	# only one positional array allowed
	local positionalarrays=0
	local positionalvalues=0
	for action in "${actions[@]}" ; do
		if [[ "$action" == "positionalvalue" ]] ; then positionalvalues=$(( positionalvalues + 1 )) ; fi
		if [[ "$action" == "positionalarray" ]] ; then positionalarrays=$(( positionalarrays + 1 )) ; fi
	done
	if [[ $positionalarrays -gt 1 ]] ; then
		__errortext "$koiname: __addarg err: there cannot be multiple positional array actions because they cannot be parsed unambiguously"
		return 1
	elif [[ $positionalarrays -eq 1 && $positionalvalues -gt 0 ]] ; then
		__errortext "$koiname: __addarg err: there cannot be combinations of positional arrays and positional values because they cannot be parsed unambiguously"
		return 1
	fi

	# only one optional positional value allowed
	if [[ $positionalvalues -gt 1 ]] ; then
		local optionalpositionalvalues=0
		local requiredpositionalvalues=0
		for index in "${!actions[@]}" ; do
			if [[ "${actions[$index]}" == "positionalvalue" && "${requireds[$index]}" == "optional" ]] ; then
				optionalpositionalvalues=$(( optionalpositionalvalues + 1 ))
			elif [[ "${actions[$index]}" == "positionalvalue" && "${requireds[$index]}" == "required" ]] ; then
				requiredpositionalvalues=$(( requiredpositionalvalues + 1 ))
			fi
		done
		if [[ $optionalpositionalvalues -gt 1 ]] ; then
			__errortext "$koiname: __addarg err: there cannot be multiple optional positional values because they cannot be parsed unambiguously"
			return 1
		elif [[ $optionalpositionalvalues -eq 1 && $requiredpositionalvalues -gt 0 ]] ; then
			__errortext "$koiname: __addarg err: there cannot be combinations of optional and required positional values because they cannot be parsed unambiguously"
			return 1
		fi
	fi

	# long options must be unique
	local compareshort=( )
	for short in "${shortoptions[@]}" ; do
		if [[ "$short" != "" ]] ; then compareshort=( "${compareshort[@]}" "$short" ) ; fi
	done
	local comparelong=( "${longoptions[@]}" )
	local shortunique=$(printf '%s\n' "${compareshort[@]}" | awk '!($0 in seen){seen[$0];c++} END {print c}')
	local longunique=$(printf '%s\n' "${comparelong[@]}" | awk '!($0 in seen){seen[$0];c++} END {print c}')
	if [[ "$shortunique" != "${#compareshort[@]}" ]] ; then
		__errortext "$koiname: __addarg err: short option names must be unique"
		return 1
	fi
	if [[ "$longunique" != "${#comparelong[@]}" ]] ; then
		__errortext "$koiname: __addarg err: long option names must be unique"
		return 1
	fi
}

function __parseargs {
	: <<- COMMENT
	Parse previously defined arguments and options
	COMMENT

	# resolve joint arguments
	local resolvedargs=( )
	for arg in "$@" ; do
		if [[ "${arg:0:1}" == "-" ]] ; then
			if [[ "${#arg}" -gt 2 && "${arg:1:1}" != "-" ]] ; then
				while read -n1 char ; do
					if [[ "$char" == "-" ]] ; then continue ; fi
					if [[ "$char" == " " ]] ; then continue ; fi
					if [[ "$char" == "" ]] ; then continue ; fi
					resolvedargs=( "${resolvedargs[@]}" "-${char}" )
				done < <(echo "$arg")
			else
				resolvedargs=( "${resolvedargs[@]}" "$arg" )
			fi  
		else
			resolvedargs=( "${resolvedargs[@]}" "$arg" )
		fi  
	done
	set -- "${resolvedargs[@]}"

	# configure colors
	local colorteal=
	local coloryellow=
	local colorreset=
	if [[ "$koicolors" -eq 1 ]] ; then
		colorteal='\033[96m'
		coloryellow='\033[93m'
		colorreset='\033[0m'
	fi

	# determine positional arguments
	local positionalargindex=0
	local positionalarguments=()
	local positionalrequireds=()
	local usepositionalarray=0
	for argindex in "${!actions[@]}" ; do
		if [[ "${actions[$argindex]}" == "positionalarray" ]] ; then
			usepositionalarray=1
			positionalarguments="${longoptions[$argindex]}"
			if [[ "${requireds[$argindex]}" == "required" ]] ; then
				positionalrequireds=required
			else
				positionalrequireds=optional
			fi
			break
		elif [[ "${actions[$argindex]}" == "positionalvalue" ]] ; then
			positionalarguments=( "${positionalarguments[@]}" "${longoptions[$argindex]}" )
			positionalrequireds=( "${positionalrequireds[@]}" "${requireds[$argindex]}" )
		fi
	done

	while [[ $# -gt 0 ]] ; do
		local key="$1"

		# get name of option/argument
		# check for flags/options first
		local option=
		local index=
		for i in `seq 0 "${#shortoptions[@]}"` ; do
			if [[ "${shortoptions[$i]}" == "$key" ]] ; then
				option="${shortoptions[$i]}"
				index=$i
				break
			elif [[ "${longoptions[$i]}" == "$key" ]] ; then
				option="${longoptions[$i]}"
				index=$i
				break
			fi
		done

		# check for positional arguments
		local positionaloption=
		local ispositional=0
		if [[ "$option" == "" ]] ; then
			if [[ "$positionalarguments" != "" ]] ; then
				option="null"
				ispositional=1
				if [[ $usepositionalarray -eq 1 ]] ; then
					positionaloption="$positionalarguments"
				else
					positionaloption="${positionalarguments[0]}"
					positionalarguments=( "${positionalarguments[@]:1}" )
				fi
			fi
		fi

		# check if we're still missing the option
		if [[ "$option" == "" ]] ; then __errortext "$koiname: err: no such option '$key'" ; return 1 ; fi

		# figure out what to do with option
		# get variable from longoption
		local varname="${longoptions[$index]#--}"

		# if action is positionalvalue or positionalarray
		if [[ $ispositional -eq 1 ]] ; then
			if [[ $usepositionalarray == 0 ]] ; then
				read $positionaloption <<< "$1"
				shift
			else
				if [[ "${!positionaloption}" == "" ]] ; then
					eval "${positionaloption}=( )"
				fi
				eval "${positionaloption}+=( \"$1\" )"
				shift
			fi

		# if action is help
		elif [[ "${actions[$index]}" == "help" ]] ; then

			# determine max indent size
			local maxindent=0
			for i in "${!longoptions[@]}" ; do
				local indent=$(( 6 + ${#longoptions[$i]} + ${#longoptions[$i]} ))
				if [[ $indent -gt maxindent ]] ; then maxindent=$indent ; fi
			done

			# build help text for positional arguments
			local positionalhelptext=
			if [[ $usepositionalarray -eq 1 ]] ; then
				# if we're using a positional array
				if [[ "$positionalrequireds" == "required" ]] ; then
					positionalhelptext="${positionalhelptext}`echo "$positionalarguments" | tr '[a-z]' '[A-Z]'`... "
				else
					positionalhelptext="${positionalhelptext}[`echo "$positionalarguments" | tr '[a-z]' '[A-Z]'`...] "
				fi
			else
				# if we're using positional values
				for argindex in "${!positionalarguments[@]}" ; do
					if [[ "${positionalrequireds[$argindex]}" == "required" ]] ; then
						positionalhelptext="${positionalhelptext}`echo "${positionalarguments[$argindex]}" | tr '[a-z]' '[A-Z]'` "
					else
						positionalhelptext="${positionalhelptext}[`echo "${positionalarguments[$argindex]}" | tr '[a-z]' '[A-Z]'`] "
					fi
				done
			fi

			# build help text for options
			local argumentshelptext=
			for i in "${!actions[@]}" ; do

				local argumentname=
				local startrequiredtext=
				local endrequiredtext=
				local argcaps=

				if [[ "${shortoptions[$i]}" != "" ]] ; then
					argumentname="${shortoptions[$i]}"
				else
					argumentname="${longoptions[$i]}"
				fi
				argcaps=`echo "${longoptions[$i]}" | sed 's/^-*//g' | tr '[a-z]' '[A-Z]'`
				if [[ "${requireds[$i]}" == "optional" ]] ; then
					startrequiredtext='['
					endrequiredtext=']'
				fi

				case "${actions[$i]}" in
					help|flag|exit )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname}${endrequiredtext} "
						;;
					storevalue|directorypath|filepath )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname} ${argcaps}${endrequiredtext} "
						;;
					storearray )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname} ${argcaps}+${endrequiredtext} "
						;;
					* )
						continue
						;;
				esac
			done

			# iterate through options and build help output
			local output=
			output="${output}>> ${coloryellow}${koiname} ${FUNCNAME[1]} ${argumentshelptext}${positionalhelptext}${colorreset}\n${helptexts[$index]}\n"
			for i in "${!shortoptions[@]}" ; do
				if [[ "${actions[$i]}" == "help" ]] ; then
					continue
				fi

				# get variable name from long option
				varname="${longoptions[$i]#--}"

				# append to output if short option exists
				if [[ "${shortoptions[$i]}" == "" ]] ; then
					local shortoptionstr=
				else
					local shortoptionstr="${shortoptions[$i]}, "
				fi

				# capitalize variable name
				local outputlength=$(( ${#shortoptionstr} + 2 + ${#longoptions[$i]} ))
				output="${output}  ${shortoptionstr}${longoptions[$i]} "
				if [[ "${actions[$i]}" == "storevalue" || "${actions[$i]}" == "storearray" || "${actions[$i]}" == "directorypath" || "${actions[$i]}" == "filepath" ]] ; then
					output="${output}`echo "${varname}" | tr '[a-z]' '[A-Z]'` "
					outputlength=$(( ${outputlength} + ${#longoptions[$i]} - 1 ))
				fi

				# calculate indent size
				local indentsize=$(( $maxindent - $outputlength ))
				local indent="`printf "%0.s " $(seq 1 $indentsize)`"

				# append help texts
				output="${output}${indent} "
				if [[ "${actions[$i]}" == "storearray" || "${actions[$i]}" == "positionalarray" ]] ; then
					output="${output}(+) "
				fi
				output="${output}${helptexts[$i]} "
				if [[ "${requireds[$i]}" == "optional" ]] ; then
					output="${output}(optional) "
					if [[ "${defaults[$i]}" != "" ]] ; then
						output="${output}(default: ${defaults[$i]})\n"
					else
						output="${output}\n"
					fi
				else
					output="${output}\n"
				fi
			done

			# print help output
			__helptext "${output}"
			exit

		# if action is flag
		elif [[ "${actions[$index]}" == "flag" ]] ; then
			read $varname <<< 1
			shift

		# handle options with arguments that need to be validated
		else
			if [[ "$2" == "" ]] ; then
				__errortext "$koiname: err: missing value for argument ${longoptions[$index]}"
				return 1
			fi

			# if action is storearray
			if [[ "${actions[$index]}" == "storearray" ]] ; then
				if [[ "${!varname}" == "" ]] ; then
					eval "${varname}=( )"
				fi
				eval "${varname}+=( \"$2\" )"
				shift
				shift

			# if action is storevalue, directorypath, filepath, or exit
			else
				if [[ "${actions[$index]}" == "directorypath" ]] ; then
					if [[ ! -d "$2" ]] ; then __errortext "$koiname: err: value for argument '${longoptions[$index]}' needs to be a directory, no such directory '$2'" ; return 1 ; fi
				elif [[ "${actions[$index]}" == "filepath" ]] ; then
					if [[ ! -f "$2" ]] ; then __errortext "$koiname: err: value for argument '${longoptions[$index]}' needs to be a file, no such file '$2'" ; return 1 ; fi
				elif [[ "${actions[$index]}" == "exit" ]] ; then
					exit
				fi
				read $varname <<< "$2"
				shift
				shift
			fi
		fi
	done

	# deal with required options
	for index in "${!requireds[@]}" ; do
		varname="${longoptions[$index]#--}"
		if [[ "${requireds[$index]}" == "required" ]] ; then
			if [[ "${!varname}" == "" ]] ; then
				__errortext "$koiname: err: missing required argument ${longoptions[$index]}"
				return 1
			fi
		else
			if [[ "${!varname}" == "" ]] ; then
				if [[ "${actions[$index]}" == "flag" ]] ; then
					read $varname <<< 0
				else
					read $varname <<< "${defaults[$index]}"
				fi
			fi				
		fi
	done
}

function __cleararglists {
	shortoptions=( )
	longoptions=( )
	actions=( )
	requireds=( )
	defaults=( )
	helptexts=( )
}

function __koirun {
	if declare -F -- "${1:-}" >/dev/null ; then
		"$@"
	else
		__errortext "$koiname: err: no such command '$1'"
		__errortext "Use 'help' for available commands"
		exit 1
	fi
}

function __helptext {
	echo -e "$@" | fold -w 100 -s
}

function __errortext {
	>&2 echo "$@"
}

function --help {
	help "$@"
}

function -h {
	help "$@"
}

function -hv {
	help -v "$@"
}