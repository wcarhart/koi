#!/bin/bash
set -e

# ============ STARTUP FUNCTIONALITY ============ #
# colors and style
__reset='\033[0m'
__bold='\033[1m'
__lightgrey='\033[90m'
__red='\033[91m'
__green='\033[92m'
__yellow='\033[93m'
__blue='\033[94m'
__pink='\033[95m'
__teal='\033[96m'
__white='\033[97m'

# configurable options
koiname=koi
koidescription="Bashful argument parsing"
koihelpmenuprefix=
koiwordwraplength=100
koishowhints=1
koicolorprimary="$__teal"
koicolorsecondary="$__yellow"
koirequirehelpactions=1

# internal variables
__koisubcommands=1
__koishortoptions=( )
__koilongoptions=( )
__koiactions=( )
__koirequireds=( )
__koidefaults=( )
__koihelptexts=( )
__koiverifyingfunctions=( )

# ============ CLI FUNCTIONS ============ #
function list {
	__addarg "-h" "--help" "help" "optional" "" "List all available commands"
	__addarg "-d" "--docs" "flag" "optional" "" "If included, print command documentation"
	__parseargs "$@"
	
	# shellcheck disable=SC2154
	if [[ "$docs" -eq 1 ]] ; then
		__commanddocs
	else
		__listfunctions
	fi
}

function help {
	__addarg "-h" "--help" "help" "optional" "" "Show this menu and exit"
	__addarg "-v" "--verbose" "flag" "optional" "" "Print verbose command documentation"
	__parseargs "$@"

	# build help menu
	local helpoutput
	helpoutput=$(cat <<- EndOfHelp
	${koicolorsecondary}${koidescription}${__reset}

	${koicolorprimary}Usage:${__reset}
	  $koiname COMMAND [args]

	${koicolorprimary}Available commands:${__reset}
	$( \
		local cmd ; \
		for cmd in $(__listfunctions) ; do \
			echo "  $cmd" ; \
		done \
	)
	EndOfHelp
	)
	echo -e "$helpoutput"
	echo

	# optional help menu additions
	# shellcheck disable=SC2154
	if [[ "$verbose" -eq 1 ]] ; then
		__commanddocs
	else
		if [[ "$koishowhints" -eq 1 ]] ; then
			helpoutput=$(cat <<- EndOfHelp
			${koicolorprimary}Hints:${__reset}
			  $koiname help --verbose    Show complete command documentation
			  $koiname COMMAND --help    Show individual command documentation

			EndOfHelp
			)
			echo -e "$helpoutput"
			echo
		fi
	fi
}

# ============ VERIFYING FUNCTIONS ============ #
function __verifyfile {
	# verify that a file exists
	# $1 is the file to verify
	if [[ ! -f "$1" ]] ; then
		__errortext "$koiname: err: no such file '$1'"
		return 1
	fi
}

function __verifydirectory {
	# verify that a directory exists
	# $1 is the directory to verify
	if [[ ! -d "$1" ]] ; then
		__errortext "$koiname: err: no such directory '$1'"
		return 1
	fi
}

function __verifyfiletype {
	# verify that a file is of a specific file type
	# $1 is the filetype to enforce
	# $2 is the file to verify
	if [[ $# -ne 2 ]] ; then
		__errortext -c "$koiname: __verifyfiletype err: incorrect number of arguments (should be 2, filetype and file)"
		return 1
	fi

	local filetype="$1"
	if [[ "${filetype:0:1}" == "." ]] ; then
		filetype="${filetype:1}"
	fi
	local file="$2"

	if [[ ! -f "$file" ]] ; then
		__errortext "$koiname: err: no such file '$file'"
		return 1
	fi

	if [[ "$file" != *".${filetype}" ]] ; then
		__errortext "$koiname: err: argument '$file' must be a $filetype file"
		return 1
	fi
}

# ============ META FUNCTIONS ============ #
function __commanddocs {
	local stdout
	local stderr
	local helpoutput="${koicolorprimary}Command documentation:${__reset}"
	local cmd
	for cmd in $(__listfunctions) ; do
		{
			IFS=$'\n' read -r -d '' stderr;
			IFS=$'\n' read -r -d '' stdout;
		} < <((printf '\0%s\0' "$(set -e ; __cleararglists ; $cmd --help)" 1>&2) 2>&1)

		if [[ "$stderr" != "" ]] ; then
			__errortext "$stderr"
			return 1
		fi
		helpoutput="${helpoutput}\n${stdout}\n"
		stdout=
	done

	echo -e "$helpoutput"
}

function __listfunctions {
	# shellcheck disable=SC2207
	functionlist=( $(declare -F | sed -e 's/declare -f //g' -e 's/[_-].*//g') )
	local func
	for func in "${functionlist[@]}" ; do
		echo "$func"
	done
}

function __addarg {
	: <<- COMMENT
	Add an argument to parse for a function
		$1 - short option (required, can be blank)
		$2 - long option (required)
		$3 - action to take with argument (required)
		$4 - whether or not argument is required (required)
		$5 - the default value for the argument (required, can be blank)
		$6 - the help text to print when -h is specified (required)
		$7 - the function used to verify the argument (optional)
	COMMENT

	if [[ $# -ne 6 && $# -ne 7 ]] ; then __errortext -c "$koiname: __addarg err: incorrect usage, either 6 or 7 arguments are required" ; return 1 ; fi

	# short option
	if [[ "$1" != "" ]] ; then
		if [[ "$1" != -* || "$1" == --* ]] ; then __errortext -c "$koiname: __addarg err: short option must start with a single dash" ; return 1 ; fi
		if [[ "${#1}" -gt 2 ]] ; then __errortext -c "$koiname: __addarg err: short options must be a single dash followed by a single letter" ; return 1 ; fi
		if [[ "$1" == *" "* ]] ; then __errortext -c "$koiname: __addarg err: short option cannot contain a space" ; return 1 ; fi
		if ! [[ "$1" =~ ^-[a-zA-Z] ]] ; then __errortext -c "$koiname: __addarg err: short option must be a letter" ; return 1 ; fi
	fi

	# long option
	if [[ "$2" == "" ]] ; then __errortext -c "$koiname: __addarg err: missing long option for argument" ; return 1 ; fi
	if [[ "$3" == "positionalvalue" || "$3" == "positionalarray" ]] ; then
		if ! [[ "$2" =~ ^[a-zA-Z]+[a-zA-Z0-9]*$ ]] ; then
			__errortext -c "$koiname: __addarg err: positional arguments must be alphanumeric and cannot start with a number"
			return 1
		fi
	else
		if [[ "$2" != --* ]] ; then
			__errortext -c "$koiname: __addarg err: long option must start with a double dash"
			return 1
		fi
		if ! [[ "$2" =~ ^--[a-zA-Z]+[a-zA-Z0-9]* ]] ; then
			__errortext -c "$koiname: __addarg err: long option must be alphanumeric and cannot start with a number"
			return 1
		fi
	fi
	if [[ "$2" == *" "* ]] ; then __errortext -c "$koiname: __addarg err: long option cannot contain a space" ; return 1 ; fi

	# action
	local availableactions="help storevalue storearray positionalvalue positionalarray flag"
	if [[ "$3" == "" ]] ; then __errortext -c "$koiname: __addarg err: missing action for argument" ; return 1 ; fi
	local found=0
	local action
	for action in $availableactions ; do if [[ "$action" == "$3" ]] ; then found=1 ; fi ; done
	if [[ $found -eq 0 ]] ; then __errortext -c "$koiname: __addarg err: action must be one of: $availableactions" ; return 1 ; fi
	if [[ "$3" == "positionalvalue" || "$3" == "positionalarray" ]] ; then
		if [[ "$1" != "" ]] ; then __errortext -c "$koiname: __addarg err: positional arguments cannot have a short name" ; return 1 ; fi
		if [[ "$2" == -* ]] ; then __errortext -c "$koiname: __addarg err: positional arguments long name cannot begin with a dash" ; return 1 ; fi
	fi
	if [[ "$3" == "help" ]] ; then
		if [[ "$1" != "-h" ]] ; then __errortext -c "$koiname: __addarg err: help actions must use '-h' for their short names" ; return 1 ; fi
		if [[ "$2" != "--help" ]] ; then __errortext -c "$koiname: __addarg err: help actions must use '--help' for their long names" ; return 1 ; fi
	fi

	# required
	if [[ "$4" == "" ]] ; then __errortext -c "$koiname: __addarg err: missing required for argument" ; return 1 ; fi
	if [[ "$4" != "required" && "$4" != "optional" ]] ; then __errortext -c "$koiname: __addarg err: required must be one of: required optional" ; return 1 ; fi
	if [[ "$3" == "help" && "$4" == "required" ]] ; then __errortext -c "$koiname: __addarg err: help option cannot be required" ; return 1 ; fi

	# default
	if [[ "$5" != "" ]] ; then
		if [[ "$4" == "required" ]] ; then __errortext -c "$koiname: __addarg err: required arguments cannot have default values" ; return 1 ; fi
		if [[ "$3" == "help" ]] ; then __errortext -c "$koiname: __addarg err: help action cannot have a default value" ; return 1 ; fi
		if [[ "$3" == "flag" ]] ; then __errortext -c "$koiname: __addarg err: flags cannot have default values" ; return 1 ; fi
		if [[ "$3" == "storearray" ]] ; then __errortext -c "$koiname: __addarg err: arrays cannot have default values" ; return 1 ; fi
		if [[ "$3" == "positionalvalue" ]] ; then __errortext -c "$koiname: __addarg err: positional values cannot have default values" ; return 1 ; fi
		if [[ "$3" == "positionalarray" ]] ; then __errortext -c "$koiname: __addarg err: positional arrays cannot have default values" ; return 1 ; fi
	fi

	# help
	if [[ "$6" == "" ]] ; then __errortext -c "$koiname: __addarg err: missing help text for argument" ; return 1 ; fi

	# verifyingfunction
	if [[ "$7" != "" ]] ; then
		local verifyingcmd="${7%% *}"
		local verifyingargs="${7##$verifyingcmd}"
		if ! declare -F -- "$verifyingcmd" >/dev/null ; then __errortext -c "$koiname: __addarg err: specified verifying function '$7' is not defined" ; return 1 ; fi
		if [[ "$3" == "help" ]] ; then __errortext -c "$koiname __addarg err: help options cannot have a verifyingfunction" ; return 1 ; fi
		if [[ "$3" == "flag" ]] ; then __errortext -c "$koiname __addarg err: flag options cannot have a verifyingfunction" ; return 1 ; fi
	fi

	# update argument lists
	__koishortoptions=( "${__koishortoptions[@]}" "$1" )
	__koilongoptions=( "${__koilongoptions[@]}" "$2" )
	__koiactions=( "${__koiactions[@]}" "$3" )
	__koirequireds=( "${__koirequireds[@]}" "$4" )
	__koidefaults=( "${__koidefaults[@]}" "$5" )
	__koihelptexts=( "${__koihelptexts[@]}" "$6" )
	__koiverifyingfunctions=( "${__koiverifyingfunctions[@]}" "$7" )

	# verify nonambiguity
	# only one positional array allowed
	local positionalarrays=0
	local positionalvalues=0
	local action
	for action in "${__koiactions[@]}" ; do
		if [[ "$action" == "positionalvalue" ]] ; then positionalvalues=$(( positionalvalues + 1 )) ; fi
		if [[ "$action" == "positionalarray" ]] ; then positionalarrays=$(( positionalarrays + 1 )) ; fi
	done
	if [[ $positionalarrays -gt 1 ]] ; then
		__errortext -c "$koiname: __addarg err: there cannot be multiple positional array actions because they cannot be parsed unambiguously"
		return 1
	elif [[ $positionalarrays -eq 1 && $positionalvalues -gt 0 ]] ; then
		__errortext -c "$koiname: __addarg err: there cannot be combinations of positional arrays and positional values because they cannot be parsed unambiguously"
		return 1
	fi

	# only one optional positional value allowed
	if [[ $positionalvalues -gt 1 ]] ; then
		local optionalpositionalvalues=0
		local requiredpositionalvalues=0
		local index
		for index in "${!__koiactions[@]}" ; do
			if [[ "${__koiactions[$index]}" == "positionalvalue" && "${__koirequireds[$index]}" == "optional" ]] ; then
				optionalpositionalvalues=$(( optionalpositionalvalues + 1 ))
			elif [[ "${__koiactions[$index]}" == "positionalvalue" && "${__koirequireds[$index]}" == "required" ]] ; then
				requiredpositionalvalues=$(( requiredpositionalvalues + 1 ))
			fi
		done
		if [[ $optionalpositionalvalues -gt 1 ]] ; then
			__errortext -c "$koiname: __addarg err: there cannot be multiple optional positional values because they cannot be parsed unambiguously"
			return 1
		elif [[ $optionalpositionalvalues -eq 1 && $requiredpositionalvalues -gt 0 ]] ; then
			__errortext -c "$koiname: __addarg err: there cannot be combinations of optional and required positional values because they cannot be parsed unambiguously"
			return 1
		fi
	fi

	# long options must be unique
	local compareshort=()
	local short
	for short in "${__koishortoptions[@]}" ; do
		if [[ "$short" != "" ]] ; then compareshort=( "${compareshort[@]}" "$short" ) ; fi
	done
	if [[ "${#compareshort[@]}" -eq 0 ]] ; then compareshort=( "_" ) ; fi
	local comparelong=( "${__koilongoptions[@]}" )
	local shortunique
	shortunique=$(printf '%s\n' "${compareshort[@]}" | awk '!($0 in seen){seen[$0];c++} END {print c}')
	local longunique
	longunique=$(printf '%s\n' "${comparelong[@]}" | awk '!($0 in seen){seen[$0];c++} END {print c}')
	if [[ "$shortunique" != "${#compareshort[@]}" ]] ; then
		__errortext -c "$koiname: __addarg err: short option names must be unique"
		return 1
	fi
	if [[ "$longunique" != "${#comparelong[@]}" ]] ; then
		__errortext -c "$koiname: __addarg err: long option names must be unique"
		return 1
	fi
}

function __parseargs {
	: <<- COMMENT
	Parse previously defined arguments and options
	Runs the following steps:
	 - verify help commands
	 - resolve joint arguments
	 - configure options
	 - resolve positional arguments
	 - parse arguments (based on action defined by __addarg)
	COMMENT

	# verify help command
	if [[ $koirequirehelpactions -eq 1 ]] ; then
		local foundhelp=0
		local action
		for action in "${__koiactions[@]}" ; do
			if [[ "$action" == "help" ]] ; then foundhelp=1 ; fi
		done
		if [[ $foundhelp -eq 0 ]] ; then
			__errortext -c "$koiname: __parseargs err: no valid help argument registered for function '${FUNCNAME[1]}'"
			return 1
		fi
	fi

	# resolve joint arguments
	local resolvedargs=( )
	local arg
	for arg in "$@" ; do
		if [[ "${arg:0:1}" == "-" ]] ; then
			if [[ "${#arg}" -gt 2 && "${arg:1:1}" != "-" ]] ; then
				while read -r -n1 char ; do
					if [[ "$char" == "-" ]] ; then continue ; fi
					if [[ "$char" == " " ]] ; then continue ; fi
					if [[ "$char" == "" ]] ; then continue ; fi
					resolvedargs=( "${resolvedargs[@]}" "-${char}" )
				done < <(echo "$arg")
			else
				resolvedargs=( "${resolvedargs[@]}" "$arg" )
			fi  
		else
			resolvedargs=( "${resolvedargs[@]}" "$arg" )
		fi  
	done
	set -- "${resolvedargs[@]}"

	# determine positional arguments
	local positionalarguments=()
	local positionalrequireds=()
	local positionalverifyingfunctions=()
	local usepositionalarray=0
	local argindex
	for argindex in "${!__koiactions[@]}" ; do
		if [[ "${__koiactions[$argindex]}" == "positionalarray" ]] ; then
			usepositionalarray=1
			# shellcheck disable=SC2178
			positionalarguments="${__koilongoptions[$argindex]}"
			# shellcheck disable=SC2178
			positionalverifyingfunctions="${__koiverifyingfunctions[$argindex]}"
			if [[ "${__koirequireds[$argindex]}" == "required" ]] ; then
				# shellcheck disable=SC2178
				positionalrequireds=required
			else
				# shellcheck disable=SC2178
				positionalrequireds=optional
			fi
			break
		elif [[ "${__koiactions[$argindex]}" == "positionalvalue" ]] ; then
			positionalarguments=( "${positionalarguments[@]}" "${__koilongoptions[$argindex]}" )
			positionalrequireds=( "${positionalrequireds[@]}" "${__koirequireds[$argindex]}" )
			positionalverifyingfunctions=( "${positionalverifyingfunctions[@]}" "${__koiverifyingfunctions[$argindex]}" )
		fi
	done

	while [[ $# -gt 0 ]] ; do
		local key="$1"

		# get name of option/argument
		# check for flags/options first
		local option=
		local index=
		local i
		for i in $(seq 0 "${#__koishortoptions[@]}") ; do
			if [[ "${__koishortoptions[$i]}" == "$key" ]] ; then
				option="${__koishortoptions[$i]}"
				index=$i
				break
			elif [[ "${__koilongoptions[$i]}" == "$key" ]] ; then
				option="${__koilongoptions[$i]}"
				index=$i
				break
			fi
		done

		# check for positional arguments
		local positionaloption=
		local positionalverifyingfunction=
		local ispositional=0
		if [[ "$option" == "" ]] ; then
			# shellcheck disable=SC2128
			if [[ "$positionalarguments" != "" ]] ; then
				option="null"
				ispositional=1
				if [[ $usepositionalarray -eq 1 ]] ; then
					positionaloption="$positionalarguments"
					positionalverifyingfunction="$positionalverifyingfunctions"
				else
					# handle option
					positionaloption="${positionalarguments[0]}"
					positionalarguments=( "${positionalarguments[@]:1}" )

					# handle verifyingfunction
					positionalverifyingfunction="${positionalverifyingfunctions[0]}"
					positionalverifyingfunctions=( "${positionalverifyingfunctions[@]:1}" )
				fi
			fi
		fi

		# check if we're still missing the option
		if [[ "$option" == "" ]] ; then __errortext "$koiname: err: no such option '$key'" ; return 1 ; fi

		# figure out what to do with option
		# get variable from longoption
		local varname="${__koilongoptions[$index]#--}"

		# if action is positionalvalue or positionalarray
		if [[ $ispositional -eq 1 ]] ; then
			if [[ $usepositionalarray == 0 ]] ; then
				# shellcheck disable=SC2229,SC2086
				read -r $positionaloption <<< "$1"
			else
				if [[ "${!positionaloption}" == "" ]] ; then
					eval "${positionaloption}=( )"
				fi
				eval "${positionaloption}+=( \"$1\" )"
			fi

			# run verifyingfunction, if one is registered
			if [[ "$positionalverifyingfunction" != "" ]] ; then
				local verifyingcmd="${positionalverifyingfunction%% *}"
				local verifyingargs="${positionalverifyingfunction##$verifyingcmd}"
				# shellcheck disable=SC2086
				$verifyingcmd $verifyingargs "$1"
			fi

			# move to the next argument
			shift

		# if action is help
		elif [[ "${__koiactions[$index]}" == "help" ]] ; then

			# determine max indent size
			local maxindent=0
			local i
			for i in "${!__koilongoptions[@]}" ; do
				local indent="${#__koilongoptions[$i]}"
				local action="${__koiactions[$i]}"
				if [[ "$action" == "storevalue" || "$action" == "storearray" ]] ; then
					indent=$(( indent + ${#__koilongoptions[$i]} + 9 ))
				elif [[ "$action" != "positionalvalue" && "$action" != "positionalarray" ]] ; then
					local indent=$(( indent + 10 ))
				fi
				if [[ $indent -gt maxindent ]] ; then maxindent=$indent ; fi
			done

			# build help text for positional arguments
			local positionalhelptext=
			if [[ $usepositionalarray -eq 1 ]] ; then
				# if we're using a positional array
				# shellcheck disable=SC2128
				if [[ "$positionalrequireds" == "required" ]] ; then
					positionalhelptext="${positionalhelptext}$(echo "$positionalarguments" | tr '[:lower:]' '[:upper:]')... "
				else
					positionalhelptext="${positionalhelptext}[$(echo "$positionalarguments" | tr '[:lower:]' '[:upper:]')...] "
				fi
			else
				# if we're using positional values
				local argindex
				for argindex in "${!positionalarguments[@]}" ; do
					if [[ "${positionalrequireds[$argindex]}" == "required" ]] ; then
						positionalhelptext="${positionalhelptext}$(echo "${positionalarguments[$argindex]}" | tr '[:lower:]' '[:upper:]') "
					else
						positionalhelptext="${positionalhelptext}[$(echo "${positionalarguments[$argindex]}" | tr '[:lower:]' '[:upper:]')] "
					fi
				done
			fi

			# build help text for options
			local argumentshelptext=
			local i
			for i in "${!__koiactions[@]}" ; do

				local argumentname=
				local startrequiredtext=
				local endrequiredtext=
				local argcaps=

				if [[ "${__koishortoptions[$i]}" != "" ]] ; then
					argumentname="${__koishortoptions[$i]}"
				else
					argumentname="${__koilongoptions[$i]}"
				fi
				argcaps=$(echo "${__koilongoptions[$i]}" | sed 's/^-*//g' | tr '[:lower:]' '[:upper:]')
				if [[ "${__koirequireds[$i]}" == "optional" ]] ; then
					startrequiredtext='['
					endrequiredtext=']'
				fi

				case "${__koiactions[$i]}" in
					help|flag )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname}${endrequiredtext} "
						;;
					storevalue )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname} ${argcaps}${endrequiredtext} "
						;;
					storearray )
						argumentshelptext="${argumentshelptext}${startrequiredtext}${argumentname} ${argcaps}+${endrequiredtext} "
						;;
					* )
						continue
						;;
				esac
			done

			# iterate through options and build help output
			local finaloutput=

			# if using __koimain
			if [[ $__koisubcommands -eq 0 ]] ; then
				finaloutput="${koicolorsecondary}${koidescription}${__reset}\n\n${koicolorprimary}Usage:${__reset}\n"
			else
				local subcommandcmd="${FUNCNAME[1]} "
				local subcommandhelptext="\n${__koihelptexts[$index]}"
			fi
			finaloutput="$(__helptext clitext 0 "${finaloutput}${koihelpmenuprefix}${koicolorsecondary}${koiname} ${subcommandcmd}${argumentshelptext}${positionalhelptext}${__reset}${subcommandhelptext}\n")"
			local i
			for i in "${!__koishortoptions[@]}" ; do

				local output=

				if [[ "${__koiactions[$i]}" == "help" ]] ; then
					continue
				fi

				# get variable name from long option
				varname="${__koilongoptions[$i]#--}"

				# append to output if short option exists
				if [[ "${__koishortoptions[$i]}" == "" ]] ; then
					local shortoptionstr=
				else
					local shortoptionstr="${__koishortoptions[$i]}, "
				fi

				# capitalize variable name
				output="  ${shortoptionstr}${__koilongoptions[$i]}"
				if [[ "${__koiactions[$i]}" == "storevalue" || "${__koiactions[$i]}" == "storearray" ]] ; then
					output="${output} $(echo "${varname}" | tr '[:lower:]' '[:upper:]') "
				fi

				# calculate indent size
				local outputlength="${#output}"
				local indentsize=$(( maxindent - outputlength ))
				local indent
				indent="$(printf "%0.s " $(seq 1 $indentsize))"

				# append help texts
				output="${output}${indent}"
				if [[ "${__koiactions[$i]}" == "storearray" || "${__koiactions[$i]}" == "positionalarray" ]] ; then
					output="${output}(+) "
				fi
				output="${output}${__koihelptexts[$i]} "
				if [[ "${__koirequireds[$i]}" == "optional" ]] ; then
					output="${output}(optional) "
					if [[ "${__koidefaults[$i]}" != "" ]] ; then
						output="${output}(default: ${__koidefaults[$i]})\n"
					else
						output="${output}\n"
					fi
				else
					output="${output}\n"
				fi

				finaloutput="${finaloutput}$(__helptext argtext "$maxindent" "\n$output")"
			done

			# print help output
			echo -e "$finaloutput"
			exit

		# if action is flag
		elif [[ "${__koiactions[$index]}" == "flag" ]] ; then
			# shellcheck disable=SC2229,SC2086
			read -r $varname <<< 1
			shift

		# handle options with arguments that need to be validated
		else
			if [[ "$2" == "" ]] ; then
				__errortext "$koiname: err: missing value for argument ${__koilongoptions[$index]}"
				return 1
			fi

			# if action is storearray
			if [[ "${__koiactions[$index]}" == "storearray" ]] ; then
				if [[ "${!varname}" == "" ]] ; then
					eval "${varname}=( )"
				fi
				eval "${varname}+=( \"$2\" )"

			# if action is storevalue
			else
				# shellcheck disable=SC2229,SC2086
				read -r $varname <<< "$2"
			fi

			# run verifyingfunction, if one is registered
			if [[ "${__koiverifyingfunctions[$index]}" != "" ]] ; then
				local verifyingcmd="${__koiverifyingfunctions[$index]%% *}"
				local verifyingargs="${__koiverifyingfunctions[$index]##$verifyingcmd}"
				# shellcheck disable=SC2086
				$verifyingcmd $verifyingargs "$2"
			fi

			# move to the next argument
			shift
			shift
		fi
	done

	# deal with required options
	local index
	for index in "${!__koirequireds[@]}" ; do
		varname="${__koilongoptions[$index]#--}"
		if [[ "${__koirequireds[$index]}" == "required" ]] ; then
			if [[ "${!varname}" == "" ]] ; then
				__errortext "$koiname: err: missing required argument ${__koilongoptions[$index]}"
				return 1
			fi
		else
			if [[ "${!varname}" == "" ]] ; then
				local action="${__koiactions[$index]}"
				if [[ "$action" == "help" || "$action" == "positionalvalue" || "$action" == "positionalarray" ]] ; then
					continue
				elif [[ "$action" == "flag" ]] ; then
					# shellcheck disable=SC2229,SC2086
					read -r $varname <<< 0
				else
					# shellcheck disable=SC2229,SC2086
					read -r $varname <<< "${__koidefaults[$index]}"
				fi
			fi				
		fi
	done
}

function __cleararglists {
	__koishortoptions=( )
	__koilongoptions=( )
	__koiactions=( )
	__koirequireds=( )
	__koidefaults=( )
	__koihelptexts=( )
	__koiverifyingfunctions=( )
}

function __parsekoirc {
	# parse the ~/.koirc

	if [[ ! -f ~/.koirc ]] ; then
		__errortext -c "$koiname: __parsekoirc err: no such file ~/.koirc"
		return 1
	fi

	local configurableoptions=( koiname koidescription koihelpmenuprefix koiwordwraplength koishowhints koicolorprimary koicolorsecondary koirequirehelpactions )
	local koioption
	local koivalue
	local resolvedkoivalue
	local line
	local linecount=0
	local finished=0

	until [[ $finished -eq 1 ]] ; do
		# read line from ~/.koirc
		(( linecount + 1 ))
		read -r line || finished=1
		if [[ "$line" == "" ]] ; then continue ; fi
		if [[ "${line:0:1}" == "#" ]] ; then continue ; fi
		if [[ "$line" != *=* ]] ; then
			__errortext "$koiname: err: invalid syntax in ~/.koirc, line $linecount"
			return 1
		fi
		koioption=$(echo "${line%=*}" | xargs)

		# validate variable
		local found=0
		local option
		for option in "${configurableoptions[@]}" ; do
			if [[ "$option" == "$koioption" ]] ; then found=1 ; fi
		done
		if [[ $found -eq 0 ]] ; then
			__errortext "$koiname: err: invalid option declared in ~/.koirc, '$koioption' is not configurable"
			return 1
		fi

		# set up variable
		koivalue=$(echo "${line#${koioption}*=}" | xargs)
		resolvedkoivalue="$(__resolvekoircvalues "$koivalue")"
		# shellcheck disable=SC2229,SC2086
		read -r $koioption <<< "$resolvedkoivalue"

	done < ~/.koirc
}

function __resolvekoircvalues {
	# resolve a .koirc value
	# $1 is the value to resolve
	if [[ "$1" == true ]] ; then
		echo 1
	elif [[ "$1" == false ]] ; then
		echo 0
	elif [[ "$1" == bold ]] ; then
		echo "$__bold"
	elif [[ "$1" == lightgrey ]] ; then
		echo "$__lightgrey"
	elif [[ "$1" == red ]] ; then
		echo "$__red"
	elif [[ "$1" == green ]] ; then
		echo "$__green"
	elif [[ "$1" == yellow ]] ; then
		echo "$__yellow"
	elif [[ "$1" == blue ]] ; then
		echo "$__blue"
	elif [[ "$1" == pink ]] ; then
		echo "$__pink"
	elif [[ "$1" == teal ]] ; then
		echo "$__teal"
	elif [[ "$1" == white ]] ; then
		echo "$__white"
	else
		echo "$1"
	fi
}

function __koirun {
	# check for ~/.koirc
	if [[ -f ~/.koirc ]] ; then
		__parsekoirc
	fi

	# run logic
	if declare -F -- "__koimain" >/dev/null ; then
		__koisubcommands=0
		__koimain "$@"
	elif declare -F -- "${1:-}" >/dev/null ; then
		"$@"
	else
		if [[ $# -eq 0 ]] ; then
			__errortext -c "$koiname: err: a subcommand is required, but one was not provided"
			# shellcheck disable=SC2207
			local funcs=( $(__listfunctions) )
			local cmds
			cmds=$(printf ", %s" "${funcs[@]}")
			__errortext "  available subcommands:${cmds:1}"
			__errortext "  use '$koiname help --verbose' for full documentation"
			exit 1
		else
			__errortext -c "$koiname: err: no such command '$1'"
			__errortext "  Use '$koiname help' for available commands"
			exit 1
		fi
	fi
}

function __helptext {
	: <<- COMMENT
	Print text for the help menu
	$1 is which type of help text to print, can be:
	  - clitext
	  - helptext
	  - argtext
	$2 is the indent size to use, in spaces
	$3+ is the text to print
	COMMENT

	if [[ $# -lt 2 ]] ; then
		__errortext -c "$koiname: __helptext err: incorrect number of arguments, must be at least 2"
		return 1
	fi

	local texttype="$1"
	local indentsize=$2
	shift 2
	if [[ "$texttype" == "clitext" ]] ; then
		echo -ne "$@"
	elif [[ "$texttype" == "helptext" ]] ; then
		echo -e "$@" | fold -w 100 -s
	elif [[ "$texttype" == "argtext" ]] ; then
		local stringindex=0
		local oldstringindex=
		local output="$*"
		local indent
		# shellcheck disable=SC2086
		indent="$(printf "%0.s " $(seq 1 $indentsize))"
		if [[ "${#output}" -gt $koiwordwraplength ]] ; then
			while [[ $(( stringindex + koiwordwraplength )) -lt "${#output}" ]] ; do
				oldstringindex=$stringindex
				stringindex=$(( oldstringindex + koiwordwraplength ))
				local splitchar="${output:$stringindex:1}"

				local linecount=0
				while [[ "$splitchar" != " " ]] ; do
					linecount=$(( linecount + 1 ))
					stringindex=$(( stringindex - 1 ))
					if [[ $linecount -ge $(( koiwordwraplength - indentsize - 1 )) ]] ; then
						stringindex=$(( oldstringindex + koiwordwraplength ))
						break
					fi
					splitchar="${output:$stringindex:1}"
				done

				local tailstring="${output:$stringindex}"
				while [[ "${tailstring:0:1}" == " " ]] ; do
					tailstring="${tailstring:1}"
				done

				if [[ "$tailstring" != "" && "$tailstring" != '\n' ]] ; then
					output="${output:0:$stringindex}\n${indent}${tailstring}"
				fi
			done
		fi
		echo -e "$output"
	else
		__errortext -c "$koiname: __helptext err: provided text type is not one of: clitext, helptext, argtext"
		return 1
	fi
}

function __errortext {
	if [[ "$1" == "-c" || "$1" == "--color" ]] ; then
		shift
		>&2 echo -e "${__red}$*${__reset}"
	else
		>&2 echo -e "$@"
	fi
}

function --help {
	help "$@"
}

function -h {
	help "$@"
}

function -hv {
	help -v "$@"
}