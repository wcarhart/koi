#!/bin/bash
set -e

# ============ STARTUP FUNCTIONALITY ============ #
koiname=koi
koidescription="Bashful argument parsing"
shortoptions=( )
longoptions=( )
actions=( )
requireds=( )
defaults=( )
helptexts=( )

# ============ CLI FUNCTIONS ============ #
function list {
	__addarg "-h" "--help" "help" "optional" "" "List all available commands"
	__parseargs "$@"
	__listfunctions
}

function help {
	__addarg "-h" "--help" "help" "optional" "" "Show this menu and exit"
	__parseargs "$@"
	cat <<- EndOfHelp
	$koidescription

	Usage:
	  $koiname COMMAND [args]

	Available commands:
	$( \
		for cmd in `__listfunctions` ; do \
			echo "$(__cleararglists ; $cmd --help)" && \
			echo ; \
		done \
	)
	EndOfHelp
}

# ============ META FUNCTIONS ============ #
function __listfunctions {
	functionlist=( `declare -F | sed -e 's/declare -f //g' -e 's/[_-].*//g'` )
	for func in "${functionlist[@]}" ; do
		echo "$func"
	done
}

function __addarg {
	: <<- COMMENT
	Add an argument to parse for a function
		$1 - short option (optional)
		$2 - long option (required)
		$3 - action to take with argument (required)
		$4 - whether or not argument is required (required)
		$5 - the default value for the argument (optional)
		$6 - the help text to print when -h is specified (optional)
	COMMENT

	if [[ $# -ne 6 ]] ; then __errortext "$koiname: __addarg err: incorrect usage, 6 arguments are required" ; return 1 ; fi

	# short option
	if [[ "$1" != "" ]] ; then
		if [[ "$1" != -* || "$1" == --* ]] ; then __errortext "$koiname: __addarg err: short option must start with a single dash" ; return 1 ; fi
		if [[ "$1" == *" "* ]] ; then __errortext "$koiname: __addarg err: short option cannot contain a space" ; return 1 ; fi
	fi

	# long option
	if [[ "$2" == "" ]] ; then __errortext "$koiname: __addarg err: missing long option for argument" ; return 1 ; fi
	if [[ "$2" != --* ]] ; then __errortext "$koiname: __addarg err: long option must start with a double dash" ; return 1 ; fi
	if [[ "$2" == *" "* ]] ; then __errortext "$koiname: __addarg err: long option cannot contain a space" ; return 1 ; fi

	# action
	availableactions="help storevalue storearray directorypath filepath flag exit"
	if [[ "$3" == "" ]] ; then __errortext "$koiname: __addarg err: missing action for argument" ; return 1 ; fi
	found=0
	for action in $availableactions ; do if [[ "$action" == "$3" ]] ; then found=1 ; fi ; done
	if [[ $found -eq 0 ]] ; then __errortext "$koiname: __addarg err: action must be one of: $availableactions" ; return 1 ; fi

	# required
	if [[ "$4" == "" ]] ; then __errortext "$koiname: __addarg err: missing required for argument" ; return 1 ; fi
	if [[ "$4" != "required" && "$4" != "optional" ]] ; then __errortext "$koiname: __addarg err: required must be one of: required optional" ; return 1 ; fi

	# default
	if [[ "$4" == "required" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: required arguments cannot have default values" ; return 1 ; fi
	if [[ "$3" == "flag" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: flags cannot have default values" ; return 1 ; fi
	if [[ "$3" == "storearray" && "$5" != "" ]] ; then __errortext "$koiname: __addarg err: arrays cannot have default values" ; return 1 ; fi

	# help
	if [[ "$6" == "" ]] ; then __errortext "$koiname: __addarg err: missing help text for argument" ; return 1 ; fi

	shortoptions=( "${shortoptions[@]}" "$1" )
	longoptions=( "${longoptions[@]}" "$2" )
	actions=( "${actions[@]}" "$3" )
	requireds=( "${requireds[@]}" "$4" )
	defaults=( "${defaults[@]}" "$5" )
	helptexts=( "${helptexts[@]}" "$6" )
}

function __parseargs {
	# parse previously defined arguments

	while [[ $# -gt 0 ]] ; do
		local key="$1"

		# get name of option
		local option=
		local index=
		for i in `seq 0 "${#shortoptions[@]}"` ; do
			if [[ "${shortoptions[$i]}" == "$key" ]] ; then
				option="${shortoptions[$i]}"
				index=$i
				break
			elif [[ "${longoptions[$i]}" == "$key" ]] ; then
				option="${longoptions[$i]}"
				index=$i
				break
			fi
		done
		if [[ "$option" == "" ]] ; then __errortext "$koiname: err: no such option '$key'" ; return 1 ; fi

		# figure out what to do with option
		# get variable from longoption
		local varname="${longoptions[$index]#--}"

		# if action is help
		if [[ "${actions[$index]}" == "help" ]] ; then

			# determine max indent size
			local maxindent=0
			for i in "${!longoptions[@]}" ; do
				local indent=$(( 6 + ${#longoptions[$i]} + ${#longoptions[$i]} ))
				if [[ $indent -gt maxindent ]] ; then maxindent=$indent ; fi
			done

			# iterate through options and build help output
			local output=
			output="${output}>> ${koiname} ${FUNCNAME[1]}\n${helptexts[$index]}\n"
			for i in "${!shortoptions[@]}" ; do
				if [[ "${actions[$i]}" == "help" ]] ; then
					continue
				fi

				# get variable name from long option
				varname="${longoptions[$i]#--}"

				# append to output if short option exists
				if [[ "${shortoptions[$i]}" == "" ]] ; then
					local shortoptionstr=
				else
					local shortoptionstr="${shortoptions[$i]}, "
				fi

				# capitalize variable name
				local outputlength=$(( ${#shortoptionstr} + 2 + ${#longoptions[$i]} ))
				output="${output}  ${shortoptionstr}${longoptions[$i]} "
				if [[ "${actions[$i]}" == "storevalue" || "${actions[$i]}" == "storearray" || "${actions[$i]}" == "directorypath" || "${actions[$i]}" == "filepath" ]] ; then
					output="${output}`echo "${varname}" | tr '[a-z]' '[A-Z]'` "
					outputlength=$(( ${outputlength} + ${#longoptions[$i]} - 1 ))
				fi

				# calculate indent size
				local indentsize=$(( $maxindent - $outputlength ))
				local indent="`printf "%0.s " $(seq 1 $indentsize)`"

				# append help texts
				output="${output}${indent} "
				if [[ "${actions[$i]}" == "storearray" ]] ; then
					output="${output}(+) "
				fi
				output="${output}${helptexts[$i]} "
				if [[ "${requireds[$i]}" == "optional" ]] ; then
					output="${output}(optional) "
					if [[ "${defaults[$i]}" != "" ]] ; then
						output="${output}(default: ${defaults[$i]})\n"
					else
						output="${output}\n"
					fi
				else
					output="${output}\n"
				fi
			done

			# print help output
			__helptext "${output}"
			exit

		# if action is flag
		elif [[ "${actions[$index]}" == "flag" ]] ; then
			read $varname <<< 1
			shift

		# handle options with arguments that need to be validated
		else
			if [[ "$2" == "" ]] ; then
				__errortext "$koiname: err: missing value for argument ${longoptions[$index]}"
				return 1
			fi

			# if action is storearray
			if [[ "${actions[$index]}" == "storearray" ]] ; then
				if [[ "${!varname}" == "" ]] ; then
					eval "${varname}=( )"
				fi
				eval "${varname}+=( \"$2\" )"
				shift
				shift

			# if action is storevalue, directorypath, filepath, or exit
			else
				if [[ "${actions[$index]}" == "directorypath" ]] ; then
					if [[ ! -d "$2" ]] ; then __errortext "$koiname: err: value for argument '${longoptions[$index]}' needs to be a directory, no such directory '$2'" ; return 1 ; fi
				elif [[ "${actions[$index]}" == "filepath" ]] ; then
					if [[ ! -f "$2" ]] ; then __errortext "$koiname: err: value for argument '${longoptions[$index]}' needs to be a file, no such file '$2'" ; return 1 ; fi
				elif [[ "${actions[$index]}" == "exit" ]] ; then
					exit
				fi
				read $varname <<< "$2"
				shift
				shift
			fi
		fi
	done

	# deal with required options
	for index in "${!requireds[@]}" ; do
		varname="${longoptions[$index]#--}"
		if [[ "${requireds[$index]}" == "required" ]] ; then
			if [[ "${!varname}" == "" ]] ; then
				__errortext "$koiname: err: missing required argument ${longoptions[$index]}"
				return 1
			fi
		else
			if [[ "${!varname}" == "" ]] ; then
				read $varname <<< "${defaults[$index]}"
			fi				
		fi
	done
}

function __cleararglists {
	shortoptions=( )
	longoptions=( )
	actions=( )
	requireds=( )
	defaults=( )
	helptexts=( )
}

function __koirun {
	if declare -F -- "${1:-}" >/dev/null ; then
		"$@"
	else
		__errortext "$koiname: err: no such command '$1'"
		__errortext "Use 'help' for available commands"
		exit 1
	fi
}

function __helptext {
	echo -e "$@" | fold -w 100 -s
}

function __errortext {
	>&2 echo "$@"
}

function --help {
	help "$@"
}

function -h {
	help "$@"
}